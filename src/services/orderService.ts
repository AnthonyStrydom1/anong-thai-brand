
import { supabaseService } from './supabaseService';
import { VATCalculator } from '@/utils/vatCalculator';
import { shippingService, ShippingRate } from './shippingService';
import type { Database } from "@/integrations/supabase/types";

export interface OrderItem {
  product_id: string;
  product_name: string;
  product_sku: string;
  quantity: number;
  unit_price: number;
  total_price: number;
}

export interface CreateOrderData {
  customer_id: number;
  items: OrderItem[];
  shipping_address: any;
  billing_address: any;
  shipping_amount?: number;
  shipping_method?: string;
  notes?: string;
}

export class OrderService {
  async calculateShipping(address: { city: string; postalCode: string }, items: any[]): Promise<ShippingRate[]> {
    // Calculate total weight (simple estimation: 0.5kg per item)
    const totalWeight = items.reduce((total, item) => total + (item.quantity * 0.5), 0);
    
    return shippingService.calculateShipping(address, totalWeight);
  }

  async createOrder(orderData: CreateOrderData) {
    try {
      // Calculate VAT breakdown for the order
      const orderTotals = VATCalculator.calculateOrderTotals(
        orderData.items.map(item => ({
          price: item.unit_price,
          quantity: item.quantity
        })),
        orderData.shipping_amount || 0
      );

      console.log('Order VAT calculation:', orderTotals);

      // Create the order with proper VAT calculations - order_number will be auto-generated by trigger
      const order: Omit<Database['public']['Tables']['orders']['Insert'], 'order_number'> = {
        customer_id: orderData.customer_id,
        subtotal: orderTotals.totalExclVAT, // Subtotal excluding VAT
        vat_amount: orderTotals.vatAmount, // Total VAT amount
        shipping_amount: orderData.shipping_amount || 0,
        total_amount: orderTotals.totalAmount, // Total including VAT
        shipping_address: orderData.shipping_address,
        billing_address: orderData.billing_address,
        shipping_method: orderData.shipping_method,
        notes: orderData.notes,
        status: 'pending',
        payment_status: 'pending',
        fulfillment_status: 'unfulfilled'
      };

      // Create the order
      const createdOrder = await supabaseService.createOrder(order);
      console.log('Created order:', createdOrder);

      // Create order items
      for (const item of orderData.items) {
        await supabaseService.createOrderItem({
          order_id: createdOrder.id,
          product_id: item.product_id,
          product_name: item.product_name,
          product_sku: item.product_sku,
          quantity: item.quantity,
          unit_price: item.unit_price,
          total_price: item.total_price
        });
      }

      return createdOrder;
    } catch (error) {
      console.error('Error creating order:', error);
      throw error;
    }
  }

  async getOrderById(orderId: string) {
    try {
      return await supabaseService.getOrder(orderId);
    } catch (error) {
      console.error('Error fetching order:', error);
      throw error;
    }
  }

  async getCustomerOrders(customerId: number) {
    try {
      return await supabaseService.getOrders(customerId);
    } catch (error) {
      console.error('Error fetching customer orders:', error);
      throw error;
    }
  }

  async updateOrderStatus(orderId: string, status: string) {
    try {
      return await supabaseService.updateOrderStatus(orderId, status);
    } catch (error) {
      console.error('Error updating order status:', error);
      throw error;
    }
  }

  async updatePaymentStatus(orderId: string, paymentStatus: string) {
    try {
      return await supabaseService.updatePaymentStatus(orderId, paymentStatus);
    } catch (error) {
      console.error('Error updating payment status:', error);
      throw error;
    }
  }
}

export const orderService = new OrderService();
